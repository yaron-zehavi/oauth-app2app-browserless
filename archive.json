{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-09-04T01:17:35.329447+00:00",
  "repo": "yaron-zehavi/oauth-app2app-browserless",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOOlAD9M7CrTyc",
      "title": "RAR type as container of native_callback_uri",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/3",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "- Seems cleaner than structured scope\n- Simpler to get WG consent for a RAR type than a new top-level OAuth parameter\n- Should native_callback_uri equal the client's redirect_uri? NO - as this validation works ONLY for the 1st AS in the originating trust domain\n\n```\nProposed structure:\n{\n   \"type\": \"https://scheme.example.org/native_callback_uri\",\n   \"locations\": [\n      \"https://app.example.com/native_callback_uri\"\n   ]\n}\n```",
      "createdAt": "2025-07-26T21:16:43Z",
      "updatedAt": "2025-07-28T14:19:01Z",
      "closedAt": "2025-07-28T14:19:01Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOOlAD9M7CrUfp",
      "title": "Consider adding new native_authorization_endpoint and corresponding AS metadata",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/4",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "A new endpoint and corresponding authorization server metadata.\nNote - AS may reuse existing authorization_endpoint instead of creating separate one, or add a path / query parameter to their existing one.\nBy providing native_authorization_endpoint, AS commits to:\n- Supporting the RAR type\n- Forwarding the RAR type\n- Redirecting with 30x and not JS / HTTP Form Post\n- Does not throw captcha if called without cookies",
      "createdAt": "2025-07-26T21:17:58Z",
      "updatedAt": "2025-07-28T14:12:39Z",
      "closedAt": "2025-07-28T14:12:39Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOOlAD9M7CrYJF",
      "title": "Routing guidance",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/5",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Some AS might need to interact with the user solely for routing inputs (choose your Bank, choose your University, etc).\nSuch interactions using html are undesired as they:\n- Break the browser-less flow.\n- Can't share remembered choices made on browser (cookie), with client app\n\nCurrently it's declared as an unsupported case.\nPerhaps AS requiring routing choice can provide app a JSON document using the content-type: **application/vnd.oauth.app2app.routing+json;** \n\n \n```\n \n{\n  // logo of AS\n  \"logo\":\"uri or base64-encoded logo\",\n  // Pre-defined selection, usually a drop down select box\n  \"options\": {\n    // request param name is \"city\" for this option\n    \"city\": {\n      \"title\": \"Location\",\n      \"description\": \"Choose the city in you work\",\n      \"hint\": \"Enter your email\",\n      \"values\": {\n        \"berlin\": { \"name\": \"Berlin\", \"logo\": \"uri or base64-encoded logo\" },\n        \"madrid\": { \"name\": \"Madrid\", \"logo\": \"uri or base64-encoded logo\"  }\n      }\n    },\n    // request param name is \"department\" for this option\n    \"department\": {\n      \"title\": \"Department\",\n      \"description\": \"Choose your department\",\n      \"hint\": \"Enter your email\",\n      \"values\": {\n        \"d123\": \"Finance\",\n        \"d456\": \"IT\"\n      }\n    }\n    // ...\n  },\n  // Free text inputs\n  \"inputs\": {\n    // request param name is \"username\" for this input field\n    \"email\": { \"hint\": \"Enter your email\", \"title\": \"E-Mail\", \"description\": \"Lore Ipsum\" }\n    // ...\n  },\n  // Response must have either\n  \"post\": \"url to POST to using application/x-www-form-urlencoded\",\n  // or\n  \"get\": \"url to use for a GET with query params\"\n  // not both\n}\n \n```\n\nThe body shall instruct on the options, how to display them (name, logo) and how to respond.\nThe response should provide a cookie to denote the session\n\nThis enables client to present routing options to end-user and provide the decisions to AS.",
      "createdAt": "2025-07-26T21:32:03Z",
      "updatedAt": "2025-07-28T21:31:21Z",
      "closedAt": "2025-07-28T21:31:21Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOOlAD9M7CrYTW",
      "title": "Implementation notes - Client should detect AS url is claimed on device and if so go there directly and not use this protocol",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/6",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-26T21:33:20Z",
      "updatedAt": "2025-07-28T14:28:58Z",
      "closedAt": "2025-07-28T14:28:58Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOOlAD9M7Cwbvu",
      "title": "Client implementation notes - rememeber downgrades",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/7",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "- If downgrade happened because of HTTP 2xx - consider back off period (30/60/90d) before retrying\n- If downgrade happened because no app claimed the url - retry policy",
      "createdAt": "2025-07-27T22:09:49Z",
      "updatedAt": "2025-07-28T21:31:41Z",
      "closedAt": "2025-07-28T21:31:41Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOOlAD9M7DJsF1",
      "title": "Reword App2Web",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/8",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Will it happen directly or as fallback?",
      "createdAt": "2025-07-29T15:36:29Z",
      "updatedAt": "2025-07-29T21:35:17Z",
      "closedAt": "2025-07-29T21:35:17Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOOlAD9M7DJuM_",
      "title": "Routing app in the middle",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/9",
      "state": "OPEN",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Which entails: \n- JSON response (either Routing Instructions Response [better name needed], next native_authorization_endpoint or deep_link to natively invoke)\n- No HTTP 3xx\n- No Cookies\n\nThis eliminates the app in the middle problem, which might have been invoked, then attempt to route forward, but Client App would have rejected as the url is not in allowList.\n\nAny AS offering an app which MAY be invoked for routing:\n- It needs to first offer a routing options response\n- Based on end-user's response decide if app should be invoked (as final AS), or skip to next hop",
      "createdAt": "2025-07-29T15:39:17Z",
      "updatedAt": "2025-08-06T12:59:14Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOOlAD9M7DJvv0",
      "title": "Reword protocol flow to include routing options",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/10",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-29T15:41:26Z",
      "updatedAt": "2025-07-29T19:26:13Z",
      "closedAt": "2025-07-29T19:26:13Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOOlAD9M7HB_LB",
      "title": "Add more introductory context",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/12",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": ">In federated [[App2App](https://yaron-zehavi.github.io/oauth-app2app-browserless/draft-zehavi-oauth-app2app-browserless-06/draft-zehavi-oauth-app2app-browserless.html#App2App)] scenarios the web browser serves as user-agent, as federated Authorization Servers url's are not claimed by any native app.\n\nI feel like this assumes a lot of the reader to really understand the context of what is being solved with this specification. Maybe something like...\n\nIn federated app2app scenarios the web browser services as a user-agent allowing the user to cross trust domain boundaries via web based redirects. Even if a given authorization server in the chain has a native app it won't be used as the flow in constrained to the web browser.",
      "createdAt": "2025-08-20T18:49:23Z",
      "updatedAt": "2025-09-02T21:01:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaron-zehavi",
          "authorAssociation": "OWNER",
          "body": "Thanks!\nThe introduction says: \"In federated App2App scenarios the **web browser** serves as user-agent, as federated Authorization Servers url's are not claimed by any native app.\"\n\nI disagree with your 2nd sentence: \"Even if a given authorization server in the chain has a native app it won't be used as the flow in constrained to the web browser\". If a browser encounters a url claimed on the device, it may prompt the user to open the app.",
          "createdAt": "2025-08-20T20:18:42Z",
          "updatedAt": "2025-08-20T20:18:42Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "COLLABORATOR",
          "body": "That is true, however, I suspect that the redirect URLs used for browser flows would not map to the deep links bound to native mobile apps. Maybe there is a better way to communicate the concept. I think the main point you are trying to make is that today, flows in the browser stay in the browser. I found the second half of the sentence \"as federated Authorization Server url's are not claimed by any native app.\" to be confusing to the point I thought was being made.\n\nI think the web browser is serving as the user-agent because it is a simple, consistent mechanisms to cross the trust domain boundaries and support these multi-level deep federations. I don't think claimed deep link urls are relevant to that concept other than if the AS didn't deep link one of its redirect urls it would break the flow and confuse the user.",
          "createdAt": "2025-08-20T21:46:32Z",
          "updatedAt": "2025-08-20T21:46:32Z"
        },
        {
          "author": "WZHYAZE",
          "authorAssociation": "NONE",
          "body": "The intention of the sentence:\n\"In federated _App2App_ scenarios the web browser serves as user-agent, as federated Authorization Servers url's are not claimed by any native app\"\n\n... Is to explain why usage of the browser is currently unavoidable.\nIt's not yet to explain the proposed protocol flow. So maybe a less-confusing rephrase could be:\n\"When _App2App_ is performed in federation scenarios as described here, a purely native user-experience is not achieved, because a web browser must act as user-agent, because federated *Authorization Server's* urls are not claimed by any native app\"",
          "createdAt": "2025-09-01T20:55:41Z",
          "updatedAt": "2025-09-02T21:01:15Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOOlAD9M7HB_k2",
      "title": "Guide request routing?",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/13",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": ">Prompts end-user, then provides their input to Authorization Server to guide request routing.\n\nStep 3 of the overview flow\n\nI'm not sure what `guide request routing` means",
      "createdAt": "2025-08-20T18:50:07Z",
      "updatedAt": "2025-09-01T20:56:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaron-zehavi",
          "authorAssociation": "OWNER",
          "body": "It means provide input for AS to decide where to federate next.\nFor example the AS is a router across banks ==> user needs to choose bank.\nOr a router across organizations ==> user needs to enter email which guides which IDP to redirect to.\n\nTake a look at the [examples](https://www.ietf.org/archive/id/draft-zehavi-oauth-app2app-browserless-06.html#name-routing-response) and tell me please if this is still unclear",
          "createdAt": "2025-08-20T20:21:09Z",
          "updatedAt": "2025-08-20T20:21:09Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of thoughts...\n1. Is the email something that could have been provided at the original AS? i.e. are there ways to provide information to the original AS that can passed down to each subsequent as (there are of course potential privacy concerns in this regard)\n2. The concept makes sense, but for someone reading the doc without any context, the phrasing won't make sense until they've finished reading the spec. Options would be to describe the concept in the terminology section so that the reader is exposed to the concept before seeing it in section 3.1?",
          "createdAt": "2025-08-20T21:51:40Z",
          "updatedAt": "2025-08-20T21:51:40Z"
        },
        {
          "author": "WZHYAZE",
          "authorAssociation": "NONE",
          "body": "I propose closing this issue for now, and see if others find it clear or confusing",
          "createdAt": "2025-09-01T20:56:52Z",
          "updatedAt": "2025-09-01T20:56:52Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "I_kwDOOlAD9M7HCJht",
      "title": "native authorization endpoint and/or authorization challenge endpoint",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/14",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [3.3. ](https://yaron-zehavi.github.io/oauth-app2app-browserless/draft-zehavi-oauth-app2app-browserless-06/draft-zehavi-oauth-app2app-browserless.html#section-3.3)[native_authorization_endpoint](https://yaron-zehavi.github.io/oauth-app2app-browserless/draft-zehavi-oauth-app2app-browserless-06/draft-zehavi-oauth-app2app-browserless.html#name-native_authorization_endpoi)\nThis is an OAuth authorization endpoint, interoperable with other OAuth RFCs.\n\nJust wondering what the differences are between the `native authorization endpoint` and the `authorization challenge endpoint` in the OAuth for First Party Apps draft. It feels like these two endpoints are doing very similar things. There are differences... I'm just wondering if we are creating a lot of new endpoints that Authorization Servers have to support to be compliant with the new flows. Note that FedCM defines new endpoints for Authorization Servers as well.",
      "createdAt": "2025-08-20T19:05:50Z",
      "updatedAt": "2025-08-20T21:54:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaron-zehavi",
          "authorAssociation": "OWNER",
          "body": "`native authorization endpoint` is OAuth as REST API, to support native apps natively consuming other apps to serve as authorization server.\n`authorization challenge endpoint` serves the first party app of a User-Interacting Authorization Server.\nBoth standards could be used at the same time:\n\n- Client app uses `native authorization endpoint` to traverse authorization servers and reach `User-Interacting Authorization Server app`\n- `User-Interacting Authorization Server app` uses `authorization challenge endpoint` to query its AS how to properly authenticate the user\n\nI'm with you on the some variation of Moore's law seems to apply to OAuth ecosystem bloating.\nBut I guess that comes with maturity. Otherwise we'd conflate endpoints, overload functionality and confuse.\nThe dedicated `native authorization endpoint` was a proposal by Joseph Heenan, \"Godfather\" of app2app :-)\n",
          "createdAt": "2025-08-20T20:26:37Z",
          "updatedAt": "2025-08-20T20:26:37Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the semantics are slightly different. However, they are both endpoints to be used by native apps, they both return JSON, they both handle the full suite of OAuth specs and extensions for authorization. I'm not sure there is a better solution, I just know there was a decent amount of questions around why the authorization_challenge_endpoint didn't just use the PAR endpoint :) ",
          "createdAt": "2025-08-20T21:54:23Z",
          "updatedAt": "2025-08-20T21:54:23Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOOlAD9M7HCPdv",
      "title": "Examples show both GET and POST options",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/15",
      "state": "CLOSED",
      "author": "gffletch",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> REQUIRED. A JSON object that holds the URL to which the user input MUST be sent. It only supports two keys, which are mutually exclusive:\n\nThe text says the options are mutually exclusive but the examples show both being present. ",
      "createdAt": "2025-08-20T19:14:09Z",
      "updatedAt": "2025-08-20T20:27:47Z",
      "closedAt": "2025-08-20T20:27:47Z",
      "comments": [
        {
          "author": "yaron-zehavi",
          "authorAssociation": "OWNER",
          "body": "Fixed!",
          "createdAt": "2025-08-20T20:27:47Z",
          "updatedAt": "2025-08-20T20:27:47Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOOlAD9M7HCVM7",
      "title": "Are all Authorization Servers in the chain required to support the app2app model and the native authorization endpoint?",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/16",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I realize the _Client App_ is acting a bit like the browser for these cross domain flows. However, with a web browser, it is common for the AS (acting as an OAuth client) to ensure that the user-agent used to invoke the authorization request is the same user-agent via which the redirect URL comes. This is handled with the state parameter and a cookie or a particular implementation of PKCE. I'm wondering how this security provision is preserved with the _Client App_ simulating the web-browser.",
      "createdAt": "2025-08-20T19:21:54Z",
      "updatedAt": "2025-09-02T20:50:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaron-zehavi",
          "authorAssociation": "OWNER",
          "body": "We had similar thoughts when moving to OAuth as REST API with native_authorization_endpoint, and removing cookies as a mechanism of AS binding stuff to the user agent.\nOur conclusions were:\n- OAuth specifies no requirement or mechanism based on cookies to bind state to the user agent.\n- The only provision I found is in the later [BCP rfc 9700](https://www.rfc-editor.org/rfc/rfc9700.html#section-4.2.4): \"Bind the authorization code to a confidential client or PKCE challenge\".\n- PKCE implementation and binding is not the AS' concern rather the client's (which might be a federating AS).",
          "createdAt": "2025-08-20T20:40:54Z",
          "updatedAt": "2025-08-20T20:40:54Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding is that [section 10.2 of RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749#section-10.12) was specifically added to identify this binding... here is an excerpt...\n\n>   The client MUST implement CSRF protection for its redirection URI.\n   This is typically accomplished by requiring any request sent to the\n   redirection URI endpoint to include a value that binds the request to\n   the user-agent's authenticated state (e.g., a hash of the session\n   cookie used to authenticate the user-agent).  The client SHOULD\n   utilize the \"state\" request parameter to deliver this value to the\n   authorization server when making an authorization request.",
          "createdAt": "2025-08-20T21:58:27Z",
          "updatedAt": "2025-08-20T21:58:27Z"
        },
        {
          "author": "WZHYAZE",
          "authorAssociation": "NONE",
          "body": "My conclusion from both this and the PKCE #18 issue, is that support for cookies **must** be reinstated into the draft.\nI'll use an interim to discuss the issue and the conclusions",
          "createdAt": "2025-09-02T20:50:55Z",
          "updatedAt": "2025-09-02T20:50:55Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOOlAD9M7HCZMw",
      "title": "Section 5.1 sentence a little confusing",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/17",
      "state": "CLOSED",
      "author": "gffletch",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> Client App when interacting with end-user to provide routing guiding input MUST NOT be used to request authentication credentials or any other sensitive information.\n\nMay be something like?\n\nThe ability to use the _Client App_ to ask the user for input by a Downstream Authorization Server MUST NOT be used to request authentication credentials from the user. The _Client App_ SHOULD terminate the flow if such a request is detected.",
      "createdAt": "2025-08-20T19:28:10Z",
      "updatedAt": "2025-08-20T20:45:30Z",
      "closedAt": "2025-08-20T20:45:30Z",
      "comments": [
        {
          "author": "yaron-zehavi",
          "authorAssociation": "OWNER",
          "body": "Fixed, used your proposal.",
          "createdAt": "2025-08-20T20:45:29Z",
          "updatedAt": "2025-08-20T20:45:29Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOOlAD9M7HCdkl",
      "title": "PKCE and cookies",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/issues/18",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> [5.5. ](https://yaron-zehavi.github.io/oauth-app2app-browserless/draft-zehavi-oauth-app2app-browserless-06/draft-zehavi-oauth-app2app-browserless.html#section-5.5)[Authorization code theft and injection](https://yaron-zehavi.github.io/oauth-app2app-browserless/draft-zehavi-oauth-app2app-browserless-06/draft-zehavi-oauth-app2app-browserless.html#name-authorization-code-theft-an)\nIt is RECOMMENDED that PKCE is used and that the code_verifier is tied to the Client App instance, as mitigation to authorization code theft and injection attacks.\n\nHowever, a common way to implement PKCE when used in a web-browser is for the Relying Party to write a cookie into the browser with key context information regarding the PKCE request. Then when the redirect happens, the Relying Party obtains the value of the cookie and validates that it matches the PKCE data used with the request. If it does not, the redirect/authorization request fails.\n\nOne implementation is PKCE_COOKIE = Encrypt_and_Sign(pkce_verifier). When the redirect to the relying party occurs, the relying party obtains the cookie value, validates the bits have not been modified, extracts the pkce_verifier value and uses that value with the Authorization Server. That way, only requests coming through the correct browser will succeed.\n\nHow does such an implementation work with the _Client App_ ?",
      "createdAt": "2025-08-20T19:35:32Z",
      "updatedAt": "2025-08-20T22:00:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yaron-zehavi",
          "authorAssociation": "OWNER",
          "body": "Well, I think such binding is not achievable unless we reintroduce support for cookies.\n\nPKCE code verifier storage is achievable by federating AS using server-side persistence, for example using state value as a handle. So AS would be called on its https://www.idp-3.com/redirect?code=code&state=state, and would then using state locate the code_verifier to use when exchanging code for token.\n\nBut this does not achieve binding, anyone with the url containing state would be able to call the chain. Except the final call to the client app's redirect_uri would fail because that code_verifier is in the rightful app instance and not server side.\n\nDo you think we need to bring back cookies?",
          "createdAt": "2025-08-20T20:43:29Z",
          "updatedAt": "2025-08-20T20:43:29Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to call out in the security considerations that this binding is not possible with this solution. It means that there isn't a way to detect if a different client takes over the flow which seems like a concern.",
          "createdAt": "2025-08-20T22:00:20Z",
          "updatedAt": "2025-08-20T22:00:20Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOOlAD9M6VE3zG",
      "title": "Wip",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/pull/1",
      "state": "MERGED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "draft creation",
      "createdAt": "2025-05-06T09:58:05Z",
      "updatedAt": "2025-05-06T09:58:17Z",
      "baseRepository": "yaron-zehavi/oauth-app2app-browserless",
      "baseRefName": "main",
      "baseRefOid": "dd0d08dfdc4dd535c9457e78349af72ab4ad37c9",
      "headRepository": "yaron-zehavi/oauth-app2app-browserless",
      "headRefName": "wip",
      "headRefOid": "4499b65e00929d7e292190759dd14ce029ac6ed7",
      "closedAt": "2025-05-06T09:58:13Z",
      "mergedAt": "2025-05-06T09:58:13Z",
      "mergedBy": "yaron-zehavi",
      "mergeCommit": {
        "oid": "e1d37b1219312e00540b40c1d27d3ccd4bad82e6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOOlAD9M6VFzah",
      "title": "wip1",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/pull/2",
      "state": "MERGED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-06T11:29:16Z",
      "updatedAt": "2025-05-06T11:29:35Z",
      "baseRepository": "yaron-zehavi/oauth-app2app-browserless",
      "baseRefName": "main",
      "baseRefOid": "e1d37b1219312e00540b40c1d27d3ccd4bad82e6",
      "headRepository": "yaron-zehavi/oauth-app2app-browserless",
      "headRefName": "wip",
      "headRefOid": "c6da1c32496fa8eaca9c8b6fa7391b303e96561a",
      "closedAt": "2025-05-06T11:29:30Z",
      "mergedAt": "2025-05-06T11:29:30Z",
      "mergedBy": "yaron-zehavi",
      "mergeCommit": {
        "oid": "a36b643f4da31ae9feedfbd43f3e466e01f91bbf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "PR_kwDOOlAD9M6iylJS",
      "title": "henrik",
      "url": "https://github.com/yaron-zehavi/oauth-app2app-browserless/pull/11",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-08-08T15:56:06Z",
      "updatedAt": "2025-08-08T19:01:09Z",
      "baseRepository": "yaron-zehavi/oauth-app2app-browserless",
      "baseRefName": "main",
      "baseRefOid": "60c0611adbc8b80388bd1dde4b5d090384ce6f5a",
      "headRepository": "yaron-zehavi/oauth-app2app-browserless",
      "headRefName": "henrik",
      "headRefOid": "0be05100816f4b2b3c43f7b6c8016681c14fbeef",
      "closedAt": "2025-08-08T19:01:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}